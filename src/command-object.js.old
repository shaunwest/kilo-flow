/**
 * Created by Shaun on 11/18/2014.
 */

kilo('CommandObject', ['Util'], function(Util) {
  'use strict';

  function makeConditionalCommand(commandObject, type, value) {
    commandObject.addCommand({
      specialCondition: true,
      type: type,
      value: value
    });
  }

  return {
    flowEnd: function() {
      return this.results.current().sourceObjects[0];
    },
    addCommand: function(command) {
      this.results.current().addCommand(command);
    },
    include: function(flowDefinition) {
      this.get(function(sourceObject) {
        var flowObject = flowDefinition(sourceObject);
        this.addCommand(flowObject.results.current().commandRunners[0].commandQueue);
      });
      return this;
    },
    /*next: function(sourceObjects, count) {
      var flowObject = Obj.create(FlowObject);
      return flowObject.source(sourceObjects, count, this.hookId, this.results);
    },*/
    done: function() { //TODO: change to 'end'
      this.addCommand({done: true});
      return this;
    },
    get: function(func) {
      var args = Array.prototype.slice.call(arguments, 1);
      this.addCommand({
        func: func,
        sourceAsArg: true,
        args: args,
        context: this
      });
      return this;
    },
    getOne: function(func) {
      var args = Array.prototype.slice.call(arguments, 1);
      var current = this.results.current();

      this.sourceIndex = (this.sourceIndex >= current.sourceObjects.length) ? 0 : this.sourceIndex + 1;

      current.addCommand({
        func: func,
        sourceAsArg: true,
        args: args,
        context: this
      }, this.sourceIndex);
      return this;
    },
    getLast: function(func) {
      var commandObject = this;
      var current = commandObject.results.current();
      var last = commandObject.results.last();

      last.commandRunners.forEach(function(commandRunner) {
        commandRunner.add({
          complete: true,
          func: function() {
            current.addCommand({
              func: func,
              args: [commandRunner.context]
            });
          }
        });
      });
      return this;
    },
    watch: function(prop) {
      this.addCommand({
        watchProp: prop,
        lastValue: null, // FIXED... hopefully -- doesn't work because values vary between sourceObjects
        ands: [],
        specials: []
      });
      return this;
    },
    whenGroup: function(prop, value) {
      return this.when(prop, value, true);
    },
    endGroup: function() {
      this.addCommand({endGroup: true});
      return this;
    },
    when: function(prop, value, group) {
      //value = Helper.def(value, true); // if no value is provided, assume 'true'
      this.addCommand({
        whenProp: prop,
        whenValue: value,
        isFunc: Util.isFunction(value),
        ands: [],
        specials: [],
        commands: [],
        group: group
      });
      return this;
    },
    lessThan: function(value) {
      makeConditionalCommand(this, '<', value);
      return this;
    },
    lessThanOrEqualTo: function(value) {
      makeConditionalCommand(this, '<=', value);
      return this;
    },
    greaterThan: function(value) {
      makeConditionalCommand(this, '>', value);
      return this;
    },
    greaterThanOrEqualTo: function(value) {
      makeConditionalCommand(this, '>=', value);
      return this;
    },
    equalTo: function(value) {
      makeConditionalCommand(this, '==', value);
      return this;
    },
    whenNot: function(prop) {
      return this.when(prop, false);
    },
    andWhen: function(prop, value) {
      this.addCommand({
        isLogical: true,
        logicalProp: prop,
        logicalValue: value,
        logicalType: 'and',
        isFunc: Util.isFunction(value),
        specials: []
      });
      return this;
    },
    and: function() {
      return this.andWhen();
    },
    orWhen: function(prop, value) {
      this.addCommand({
        isLogical: true,
        logicalProp: prop,
        logicalValue: value,
        logicalType: 'or',
        isFunc: Util.isFunction(value),
        specials: []
      });
      return this;
    },
    or: function() {
      return this.orWhen();
    },
    andNot: function(prop) {
      return this.and(prop, false);
    },
    set: function(prop, value, inc, format) {
      this.addCommand({
        setProp: prop,
        setValue: value,
        inc: inc,
        format: format
      });
      return this;
    },
    inc: function(prop, value, format) {
      this.set(prop, value, true, format);
      return this;
    },
    on: function(eventName) {
      this.addCommand({
        eventName: eventName
      });
      return this;
    },
    call: function(func) {
      var args = Array.prototype.slice.call(arguments, 1);
      this.addCommand({
        func: func,
        args: args
      });
      return this;
    }
  };
});
